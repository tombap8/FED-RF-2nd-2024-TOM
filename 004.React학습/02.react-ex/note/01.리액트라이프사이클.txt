[ 01.리액트 라이프사이클(life cycle) ]


1️⃣ 리액트의 생명주기

컴포넌트는 
생성(mounting) -> 업데이트(updating) -> 제거(unmounting)
의 생명주기를 가진다.

리액트 함수형 컴포넌트는 Hook을 사용한다!
리액트 클래스 컴포넌트는 라이프 사이클 메서드를 사용한다!

__________________________________
🎨 1.1. 함수형 컴포넌트 생명주기 🎨
----------------------------------

리액트에서 Hook은 함수형 컴포넌트에서 
React state와 생명주기 기능을 
연동 할 수 있게 해주는 함수이다.

Hook은 class 안에서는 동작하지 않고, 
class없이 React를 사용할 수 있게 한다.

__________________________________
🎃 리액트 훅(Hook)을 도입한 목적 🎃
----------------------------------

기존의 라이프사이클 메서드 기반이 아닌 로직 기반으로 
나눌 수 있어서 컴포넌트를 함수 단위로 잘게 쪼갤 수 있다는 장점이 있음!

라이프사이클 메서드에는 관련 없는 로직이 같은 메서드에 위치하게 되는데
이로인해 버그가 쉽게 발생하고, 무결성을 쉽게 망가지게 한다.

____________________________
🎃 Hook 사용 규칙 두가지 🎃
----------------------------

[1] 최상위 컴포넌트에서만 Hook을 호출한다.

[2] 반복문, 조건문, 중첩된 함수 내에서 Hook를 실행하지 않는다.
_________________________________________

이 규칙을 따르면 컴포넌트가 렌더링될 때마다 
항상 동일한 순서로 Hook이 호출되는 것이 보장된다.

리액트 함수 컴포넌트에서만 Hook을 호출해야 한다.
일반 JS함수에서는 Hook을 호출해서는 안된다.

_________________________
🎃 Hook의 종류와 정리 🎃
------------------------

☑️ useState
상태를 관리한다.
[state이름, setter이름] 순으로 반환 받아서 사용

const [변수, set변수] = useState(초기값);

-> set변수 (변수 첫글자 대문자)

☑️ useEffect
화면에 렌더링이 완료된 후에 실행됨!

componentDidMount와 componentDidUpdate, 
componentWillUnmount가 통합된 것!

🍓만약 화면을 다 그리기 이전에 동기화 되어야 하는 경우
useLayoutEffect를 활용한다!!!

컴포넌트 렌더링 -> useLayoutEffect 실행 -> 화면 업데이트 
순으로 effect를 실행시킬 수 있다!

☑️ useEffect 옵션 정리 :

1. 렌더링 결과가 실제 돔에 반영된 후마다 호출
useEffect(() => {});

2. 컴포넌트가 처음 나타날때 한 번 호출
useEffect(() => {}, []);

3. 조건부 effect 발생, 의존성 중 하나가 변경된다면 effect는 항상 재생성
useEffect(() => {}, [의존성1, 의존성2, ..]);

4. useEffect안에서의 return은 정리 함수(clean-up)를 사용하기위해 쓰임!
메모리 누수 방지를 위해 UI에서 컴포넌트를 제거하기 전에 수행
컴포넌트가 여러 번 렌더링 된다면 다음 effect가 수행되기 전에 
이전 effect가 정리된다!

((코드))
useEffect(()=>{
    랜더링관련코드...

    // return은 정리 함수(clean-up)
    return(()=>{
        컴포넌트 제거시 발생하는 체크구역!
    })
})

___________________________________________________________
🎃 ContextAPI 와 useContext 후크를 통한 전역상태값 관리 🎃
------------------------------------------------------------

🍓 Context API란?
전역 상태(global state) 값을 공유할 수 있도록 
React에서 고안된 방법
주로 로그인한 유저 정보, 테마, 언어 등을 저장한다.

Prop Drilling의 단점을 보완한다!

((Prop Drilling 이란?))

Prop Drilling은 컴포넌트 트리에서
컴포넌트에 직접적으로 필요한 데이터를 
props로 전달받는 것이 아니라,
단순히 컴포넌트 트리의 하위 컴포넌트로의 
props 전달을 위하여 데이터를 전달하는 과정임

🍓 Context API 사용법

[React.createContext(기본값)]
- Context 객체를 생성
createContext 함수를 호출하면 
Provider와 Consumer 컴포넌트를 반환함

파라미터로 넘겨받는 값은 
Provider를 사용하지 않았을 때 적용될 초기값

[Context.Provider]
context의 value를 변경하는 역할을 한다.
Provider 선언시 value props를 통해 
context의 value를 입력받음
이 속성값 value는 context를 통해 전역적으로 공유되는 값임!

[useContext 후크]
context의 value를 가져올 때 사용
파라미터로 넘겨받는 값은 
createContex를 통해 생성된 Context 객체임


(위의 useState / useEffect / useContext 는 기본 Hooks라고 부른다!)

참고:
https://ko.legacy.reactjs.org/docs/hooks-reference.html

☑️ React - 메모이제이션(Memoization) : 추가 Hooks

🍓 React에서 메모이제이션을 하는 방법

[1. useMemo]
[2. React.memo]
[3. useCallback]

🍓 메모이제이션(Memoization)
메모이제이션은 컴퓨터가 동일한 계산을 반복해야 할 때, 
이전에 계산한 값을 메모리에 저장함으로서 중복계산을 피하여
데이터 속도를 높이는 기술.보통 애플리케이션의 최적화를 위해 사용

1. useMemo -----------------------------------
useMemo를 사용하면 함수 컴포넌트 내부에서 발생하는 
연산을 최적화할 수 있음. 이전 값을 기억해두었다고 
조건에 따라 재활용하여 성능을 최적화 하는 용도로 사용
메모이제이션된 값을 return하는 후크다!

->> 정리: useMemo 는 객체와 같은 주소값 할당인 경우
리랜더링을 막기위해 메모이제이션 하는 리턴함수를 제공하는 후크다
+++++++++++++++++++++++++++++++++++++++++++++++++
const 변수 = useMemo(() => {return값}, [관리변수]);

관리변수 값이 변경되면 메모이제이션의 함수를 재실행함.
만약 인자를 전달하지 않는다면 매번 새롭게 계산하여 return함
___________________________________________________________

2. React.memo ------------------------------------
함수 컴포넌트에서는 일반적으로 라이프 사이클을 사용할 수 없음 
그래서 React.memo라는 함수를 사용함. 
컴포넌트의 props의 전달값이 변경돼야만 랜더링변경함
설정하여 함수 컴포넌트의 리렌더링 성능을 최적화함
(주의: 함수를 전달할 경우 매번 새로운값으로 인식함!)
-> 정리: React.memo는 컴포넌트가 전달값 변경이 없으면
메모이제이션 하는 후크다
+++++++++++++++++++++++++++++++++++++++++++++++
const Component = React.memo((props) => {
	return (컴포넌트 랜더링 코드)}
);

이전과 같은 props 값이 들어올 때는 렌더링 과정을 스킵
가장 최근에 렌더링된 결과를 재사용함 
-> 이것이 메모이제이션임! 재사용!!!

단, 컴포넌트 내부에서 useState 훜 사용시 
상태가 변경 되면 리렌더링됨
_______________________________________________________________

3. useCallback -------------------------------------
useCallback을 사용하면 만들어 놨던 함수를 재사용할 수 있음
컴포넌트가 렌더링 될 때마다 내부적으로 사용된 함수가 새롭게 
생성되는 경우, 이미 사용된 같은 함수를 메모이제이션 하여 재사용함!
-> 정리: useCallback은 함수를 메모이제이션 하는 후크다!
++++++++++++++++++++++++++++++++++++++++++++++++++++++
const [의존성변수, set의존성변수] = useState(초기값);
const 콜백 = useCallback(() => {}, 
[의존성변수]);

(주의: 콜백을 호출하는 코드가 재사용되는 메모이제이션처리 돼야 
콜백 호출이 부분 업데이트가 된다! 즉, 재사용되는 메모이제이션 처리된다!)

((한마디로!))----------------------
useMemo -> 값의 함수리턴할당,의존성
React.memo -> 컴포넌트 메모
useCallback -> 함수콜백저장,의존성
-----------------------------------

☑️ useRef
1. 특정 DOM 선택할때 주로 쓰이며 
.current 프로퍼티로 전달된 인자로 
초기화된 변경 가능한 ref 객체를 반환한다. 
-> 예) <참조할요소/컴포넌트 ref="useRef사용변수명" .../>
-> ref속성에 값으로 설정된 useRef변수를 써준다!
이변수에 담긴 요소를 사용할 수 있다! -> 변수명.current

2. 그밖에 컴포넌트가 리랜더링 되어도 변경되어서는
안되는 변수의 값이 있다면 useRef를 사용하여 일정값을 유지함!

반환된 객체는 컴포넌트의 전 생애주기를 통해 유지된다.

const myRef = useRef(null);

☑️ useReducer
/*********************************************** 
 * [ 리듀서 후크 : useReducer ]
 * 복잡한 리액트 변수값/코드 처리를 해주는 후크
 *******************************************
function 리듀서함수(리듀서변수, 호출때보낸객체) {
  switch (호출때보낸객체.type) {
    case 값1:
      처리코드;
      return 처리값;
    case 값2:
      처리코드;
      return 처리값;
    default:
      처리코드;
      return 처리값;
  }
}

function 컴포넌트() {
  const [리듀서변수, 호출메서드] = 
  useReducer(리듀서함수, 리듀서변수초기값);

  return(
    <요소 on이벤트={()=>{
      호출메서드({ type: 값 });      
    } />
  );
} ///// 컴포넌트끝 ///////
